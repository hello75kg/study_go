# 脏读和幻读

本文档介绍了数据库中常见的两种并发问题：脏读和幻读，并通过示例加以说明，同时讨论了防止这些问题的事务隔离级别和措施。

---

## 1. 脏读（Dirty Read）

### 1.1 概念
脏读指的是一个事务读取到了另一个事务尚未提交的数据。如果后续该事务回滚，则读取的数据实际上是无效的，可能导致数据不一致的问题。

### 1.2 举例说明
假设有两个事务 A 和 B：
- **事务 A**：更新用户余额，将余额从 100 修改为 200，但尚未提交。
- **事务 B**：在事务 A 未提交前读取该用户余额，结果读到了 200（脏数据）。

```sql
-- 事务 A
START TRANSACTION;
UPDATE users SET balance = 200 WHERE id = 1;
-- 此时未执行 COMMIT

-- 事务 B
START TRANSACTION;
SELECT balance FROM users WHERE id = 1;  -- 读到 200（脏读）
COMMIT;

-- 如果事务 A 回滚，则用户余额应为 100，但事务 B 已读取到错误数据
```

---

## 2. 幻读（Phantom Read）

### 2.1 概念
幻读指的是在同一个事务内，连续执行相同查询却得到不同结果的现象。这通常发生在其他事务在第一个事务查询后插入或删除了满足查询条件的数据，导致结果集发生变化。

### 2.2 举例说明
假设有两个事务 A 和 B：
- **事务 A**：查询订单表中状态为 "pending" 的订单，返回 10 条记录。
- **事务 B**：在事务 A 进行期间插入一条新的状态为 "pending" 的订单，并提交。
- **事务 A**：再次执行相同查询，结果返回 11 条记录，新增的记录就是幻读现象。

```sql
-- 事务 A
START TRANSACTION;
SELECT * FROM orders WHERE status = 'pending';  -- 返回 10 条记录

-- 事务 B
START TRANSACTION;
INSERT INTO orders (order_id, status) VALUES (101, 'pending');
COMMIT;

-- 事务 A 再次查询
SELECT * FROM orders WHERE status = 'pending';  -- 返回 11 条记录，发生幻读
COMMIT;
```

---

## 3. 事务的隔离级别
数据库提供了不同的事务隔离级别，以权衡性能和数据一致性。常见的隔离级别如下（从低到高）：

| 隔离级别           | 脏读 | 不可重复读 | 幻读 | 适用场景 |
|-------------------|------|----------|------|----------|
| **READ UNCOMMITTED**（读未提交） | 可能 | 可能 | 可能 | 允许读取未提交数据，性能最高，但数据不安全 |
| **READ COMMITTED**（读已提交）   | 否   | 可能 | 可能 | Oracle 默认隔离级别，防止脏读 |
| **REPEATABLE READ**（可重复读） | 否   | 否   | 可能 | MySQL 默认隔离级别，防止脏读和不可重复读 |
| **SERIALIZABLE**（串行化）     | 否   | 否   | 否   | 最高级别，所有事务串行执行，性能最低 |

---

## 4. 事务隔离级别与防止措施

### 4.1 防止脏读
- **措施**：将事务隔离级别设置为 `READ COMMITTED` 或更高（例如 `REPEATABLE READ`、`SERIALIZABLE`）。
- **效果**：确保事务只读取已提交的数据，从而避免脏读。

### 4.2 防止幻读
- **措施**：
    - 将事务隔离级别设置为 `SERIALIZABLE`，强制事务串行执行。
    - 或采用锁机制（如悲观锁）防止其他事务在查询期间修改数据。
- **效果**：保证在同一事务内多次查询结果一致，但可能会影响系统并发性能。

---

## 5. 总结

- **脏读**：一个事务读取到另一个事务未提交的数据，可能导致读取无效数据；通过提高隔离级别可以避免。
- **幻读**：在同一事务中重复查询时，由于其他事务的插入或删除而导致结果集发生变化；采用更高级的隔离级别或锁机制可以防止幻读。

通过合理设计事务的隔离级别和采用适当的锁策略，可以在保证系统并发性的同时有效防止脏读和幻读问题。

---