# TCC 和 Saga

## 1. 分布式事务的挑战

在分布式系统中，多个服务或数据库需要共同完成一个业务操作，而每个服务都有自己的数据存储和事务管理方式。因此，传统的数据库事务（ACID 事务）无法直接应用到分布式环境，需要采用 **分布式事务** 方案来保证数据一致性。

**常见的分布式事务问题：**
- 网络不稳定导致部分操作失败
- 某个服务宕机，导致事务无法完成
- 数据复制、分区导致的不一致

为了解决这些问题，业界提出了多种分布式事务解决方案，包括：
- **TCC（Try-Confirm-Cancel）**
- **XA（两阶段提交协议）**
- **SAGA（补偿事务）**
- **本地消息表 + 事件驱动**
- **最终一致性（基于 MQ）**

---

## 2. TCC（Try-Confirm-Cancel）事务

### **2.1 TCC 介绍**
TCC 是 **柔性事务** 方案，适用于高并发、强一致性要求的场景。TCC 事务分为三步：
1. **Try（尝试）：** 预留资源，不真正提交。
2. **Confirm（确认）：** 正式执行，提交事务。
3. **Cancel（取消）：** 释放 Try 阶段预留的资源。

TCC 适用于 **金融支付、库存扣减等需要严格保证数据一致性的场景**。

---

### **2.2 TCC 事务流程**
假设一个电商系统中，用户购买商品，需要调用：
- **账户服务（扣款）**
- **库存服务（扣减库存）**
- **订单服务（创建订单）**

#### **Step 1: Try（预留资源）**
每个服务先尝试执行，预留资源：
- 账户服务：冻结账户余额
- 库存服务：预扣库存
- 订单服务：创建未确认的订单

#### **Step 2: Confirm（提交事务）**
如果所有服务的 Try 都成功，则调用 Confirm：
- 账户服务：扣减冻结余额
- 库存服务：正式扣减库存
- 订单服务：标记订单为“已支付”

#### **Step 3: Cancel（回滚事务）**
如果任何一个服务 Try 失败或超时，则执行 Cancel：
- 账户服务：解冻账户余额
- 库存服务：恢复库存
- 订单服务：取消订单

**示例代码（Go 语言实现 TCC Try 阶段）：**
```go
func TryReserveBalance(userID int, amount float64) error {
    _, err := db.Exec("UPDATE accounts SET frozen_balance = frozen_balance + ? WHERE user_id = ?", amount, userID)
    return err
}
```

---

## 3. 其他分布式事务解决方案

### **3.1 XA（两阶段提交协议）**
**XA（eXtended Architecture）协议** 是数据库级别的分布式事务方案，分为：
- **Prepare（预提交）：** 事务管理器让所有数据库节点预提交。
- **Commit/Rollback（提交/回滚）：** 若所有节点都成功，则提交；若有失败，则回滚。

**优点：**
- 强一致性，事务提交或回滚同步完成。

**缺点：**
- **性能低**，所有节点必须等待，导致阻塞。
- **单点问题**，事务管理器失败可能导致系统无法处理事务。

**适用场景：**
- 银行系统、传统 RDBMS（MySQL、Oracle）等需要强一致性的事务。

**示例（XA 事务在 MySQL 中）：**
```sql
XA START 'txn1';
UPDATE accounts SET balance = balance - 100 WHERE user_id = 1;
XA END 'txn1';
XA PREPARE 'txn1';
XA COMMIT 'txn1'; -- 或 XA ROLLBACK 'txn1';
```

---

### **3.2 SAGA（补偿事务）**
SAGA 事务是基于 **事件驱动** 的事务管理模式，它将全局事务拆分成多个子事务，每个子事务都有对应的 **补偿操作（Compensation）** 来撤销之前的操作。

**优点：**
- 非阻塞，性能优于 XA
- 适用于跨微服务的分布式事务

**缺点：**
- **需要补偿逻辑**，开发复杂度高。
- **可能有短暂不一致性**，需要业务层容错。

**适用场景：**
- 订单、机票、酒店预订等需要保证事务性的业务。

**示例（SAGA 事务流）：**
1. 订单服务 -> 预订机票
2. 酒店服务 -> 预订酒店
3. 若酒店服务失败，则触发 **机票取消补偿**

**示例代码（Go SAGA 事务管理）：**
```go
func bookHotel() error {
    err := db.Exec("INSERT INTO reservations (user_id, hotel_id) VALUES (?, ?)", userID, hotelID)
    if err != nil {
        cancelFlight()
    }
    return err
}

func cancelFlight() {
    db.Exec("DELETE FROM reservations WHERE user_id = ?", userID)
}
```

---

### **3.3 本地消息表 + 事件驱动**
该方案利用 **数据库表存储事务消息**，异步发送消息队列（MQ），确保事务最终一致。

**步骤：**
1. 事务提交时，将消息写入数据库表（本地事务保证原子性）。
2. 监听定时任务扫描未发送的消息，并发送到消息队列（MQ）。
3. 消费者获取消息并执行相应的业务逻辑。

**优点：**
- **性能高**，事务执行后异步补偿
- **可靠性高**，数据不会丢失

**缺点：**
- **消息投递有延迟**
- **需要额外管理消息状态**

**示例（Go 实现本地消息表 + Kafka）：**
```go
func saveMessageAndCommitTx(db *sql.DB, message string) error {
    tx, _ := db.Begin()
    _, err := tx.Exec("INSERT INTO message_log (msg) VALUES (?)", message)
    if err != nil {
        tx.Rollback()
        return err
    }
    return tx.Commit()
}
```

---

## 4. 分布式事务方案对比

| 方案 | 一致性 | 可用性 | 适用场景 | 开发复杂度 |
|------|--------|--------|---------|------------|
| **TCC** | 强一致性 | 适中 | 支付、金融 | 高 |
| **XA** | 强一致性 | 低 | 传统数据库事务 | 高 |
| **SAGA** | 最终一致性 | 高 | 订单、机票预订 | 中等 |
| **本地消息表** | 最终一致性 | 高 | 异步事务 | 低 |

---

## 5. 结论

### **选择合适的事务方案**
- **强一致性需求（银行、金融支付）：** **TCC 或 XA**
- **高并发微服务（电商、订单处理）：** **SAGA**
- **异步事务（日志、库存更新）：** **本地消息表 + MQ**

### **TCC vs SAGA**
- TCC 适用于**强一致性要求的业务**
- SAGA 适用于**可接受短暂不一致的业务**

综合来看，不同的分布式事务方案各有优缺点，企业应根据业务需求选择合适的解决方案。