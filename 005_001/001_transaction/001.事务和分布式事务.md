# 事务和分布式事务详细介绍

本篇文档详细介绍 **事务** 和 **分布式事务** 的概念、原理、常见实现方案及其优缺点。

---

## 1. 事务（Transaction）

事务（Transaction）是数据库操作的最小执行单元，保证数据库操作的完整性和一致性。事务遵循 **ACID** 特性：

### 1.1 事务的 ACID 特性
- **原子性 (Atomicity)**  
  事务是一个不可分割的整体，要么全部成功，要么全部失败。如果事务中的某个操作失败，则所有已执行的操作必须回滚。

- **一致性 (Consistency)**  
  事务执行前后，数据库必须从一个一致性状态转变为另一个一致性状态，不会出现数据损坏或矛盾。

- **隔离性 (Isolation)**  
  并发执行的事务相互独立，事务的执行结果不会受到其他事务的干扰。

- **持久性 (Durability)**  
  事务一旦提交，数据将被永久保存，即使系统崩溃或宕机，也不会丢失数据。

---

### 1.2 事务示例
```sql
-- 开始事务
START TRANSACTION;

-- 扣减账户余额
UPDATE accounts SET balance = balance - 100 WHERE id = 1;

-- 增加商户收入
UPDATE merchants SET revenue = revenue + 100 WHERE id = 10;

-- 提交事务
COMMIT;
```

如果在 `UPDATE merchants` 语句执行前系统崩溃，则整个事务回滚，保证数据的一致性。

---

### 1.3 事务的隔离级别
数据库提供了不同的事务隔离级别，以权衡性能和数据一致性。常见的隔离级别如下（从低到高）：

| 隔离级别           | 脏读 | 不可重复读 | 幻读 | 适用场景 |
|-------------------|------|----------|------|----------|
| **READ UNCOMMITTED**（读未提交） | 可能 | 可能 | 可能 | 允许读取未提交数据，性能最高，但数据不安全 |
| **READ COMMITTED**（读已提交）   | 否   | 可能 | 可能 | Oracle 默认隔离级别，防止脏读 |
| **REPEATABLE READ**（可重复读） | 否   | 否   | 可能 | MySQL 默认隔离级别，防止脏读和不可重复读 |
| **SERIALIZABLE**（串行化）     | 否   | 否   | 否   | 最高级别，所有事务串行执行，性能最低 |

---

## 2. 分布式事务（Distributed Transaction）

### 2.1 什么是分布式事务？
分布式事务指的是涉及 **多个数据库** 或 **多个服务** 之间的事务，需要确保不同数据源之间的数据一致性。

常见的场景：
- 订单系统需要更新 **用户账户数据库** 和 **库存数据库**。
- 支付系统需要更新 **银行账户数据库** 和 **交易记录数据库**。

由于涉及多个独立的数据源，分布式事务的实现比本地事务更加复杂。

---

### 2.3 CAP 定理

#### CAP 定理指出，分布式系统不能同时满足：
- **一致性（Consistency）**：所有节点的数据保持一致。
- **可用性（Availability）**：请求能得到及时响应。
- **分区容错性（Partition Tolerance）**：系统能在网络分区时继续运行。

#### **举例**
- **CA（强一致性 + 高可用，但不容忍分区）**：传统的 **单机数据库**，如 MySQL。
- **CP（强一致性 + 分区容错，但可能降低可用性）**：如 **Zookeeper**，保证数据一致，但部分请求可能失败。
- **AP（高可用 + 分区容错，但最终一致性）**：如 **Cassandra、DynamoDB**，数据可能有短暂不一致。

---

### 2.4 幂等性（Idempotency）

幂等性指 **相同的操作执行多次，结果不变**。

#### **举例**
```http
# 幂等的 HTTP 请求
PUT /user/1/balance {"amount": 1000}
```
无论调用多少次，用户余额始终是 **1000**，而不是累加。

非幂等操作：
```http
# 非幂等的 HTTP 请求
POST /user/1/balance {"amount": 100}
```
每次调用都会 **增加 100**，导致数据不同。

---

### 2.5 分布式锁（Distributed Lock）

分布式锁用于 **多个服务竞争同一资源** 时，确保互斥访问。

#### **举例**
使用 **Redis** 实现分布式锁：
```go
conn := redisPool.Get()
defer conn.Close()

// 尝试获取锁
lockKey := "lock:order:123"
ok, _ := redis.String(conn.Do("SET", lockKey, "1", "NX", "EX", 30))

if ok != "OK" {
    fmt.Println("获取锁失败")
    return
}

// 处理业务逻辑
processOrder()

// 释放锁
conn.Do("DEL", lockKey)
```
如果多个进程同时尝试处理订单 `123`，只有 **第一个成功获取锁的进程** 能执行 `processOrder()`，避免并发问题。



### 2.6 分布式事务的解决方案

#### 2.6.1 两阶段提交（2PC, Two-Phase Commit）
两阶段提交（2PC）是最常见的分布式事务协议，由 **协调者（Coordinator）** 和 **多个参与者（Participants）** 组成。

- **阶段一：准备阶段（Prepare Phase）**  
  协调者向所有参与者发送 “准备提交” 请求，参与者执行本地事务，但不提交，并锁定相关资源。

- **阶段二：提交阶段（Commit Phase）**  
  如果所有参与者都同意提交，协调者发送 **提交** 请求；否则，发送 **回滚** 请求，释放资源。

**缺点**：
- 参与者在 `Prepare` 阶段锁定资源，可能导致长时间的数据库锁，影响性能。
- 如果协调者崩溃，可能会导致事务挂起。

---

#### 2.6.2 三阶段提交（3PC, Three-Phase Commit）
三阶段提交（3PC）在 2PC 的基础上增加了一个 **超时机制**，避免协调者崩溃时事务长时间锁定。

- **阶段一：CanCommit**  
  询问所有参与者是否可以执行事务，避免资源锁定过久。

- **阶段二：PreCommit**  
  参与者执行事务，但仍不提交，并等待最终指令。

- **阶段三：Commit**  
  协调者通知参与者提交或回滚事务。

**优点**：
- 解决了 2PC 挂起问题，避免事务一直占用资源。

**缺点**：
- 增加了网络通信的次数，导致性能下降。

---

#### 2.6.3 Saga 模式
Saga 是一种基于补偿的事务模型，它将 **一个大事务拆分为多个子事务**，每个子事务成功后，执行下一个子事务。如果某个子事务失败，则执行 **补偿事务** 进行回滚。

**示例：电商订单系统**
1. **创建订单**（子事务1）
2. **扣减库存**（子事务2）
3. **扣减余额**（子事务3）

如果 **子事务 3 失败**，则执行补偿事务：
- **补偿事务 1**：取消订单
- **补偿事务 2**：回滚库存

**优点**：
- 适用于跨数据库和跨服务的事务处理。
- 避免 2PC 长时间占用数据库锁。

**缺点**：
- 需要额外设计 **补偿逻辑**，增加开发复杂度。

---

### 2.7 对比

| 方案 | 适用场景 | 优点 | 缺点 |
|------|---------|------|------|
| **本地事务** | 单一数据库 | ACID 保证，性能高 | 只能在单个数据库中使用 |
| **2PC** | 分布式数据库，数据强一致性 | 确保所有节点事务一致 | 资源锁定时间长，协调者单点故障 |
| **3PC** | 高可用系统，容忍网络超时 | 解决 2PC 挂起问题 | 网络开销较大，事务提交延迟 |
| **Saga** | 微服务架构，最终一致性 | 适用于长事务，性能高 | 需要设计补偿机制，开发复杂 |

对于 **高一致性** 需求，可以使用 **2PC / 3PC**，但会带来性能损耗。  
对于 **高性能、最终一致性** 需求，推荐 **Saga 模式**。

---

### 2.8 分布式事务的挑战
- **一致性 vs. 可用性**：强一致性的事务通常影响系统性能和可用性。
- **网络延迟**：跨服务事务涉及网络通信，可能导致事务超时或失败。
- **分布式锁**：多个服务竞争资源时，可能导致死锁或性能问题。

---
